<!doctype html>
<html>
<head>
  <meta charset=utf-8>
  <title>GBA.js</title>
  <link rel=stylesheet href="../style.css">
</head>
<body>

  <div id=main class=story>

    <h1>The making of GBA.js</h1>

    <h2>Episode 4: Accessing the memory</h2>
    <article>
      As described <a href="http://nocash.emubase.de/gbatek.htm#gbamemorymap">here</a> and <a href="http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Memory%20Map">here</a>, the GBA memory can be seen as a huge array of bytes, with indexes going from 0x00000000 to 0x0E00FFFF. Such an array would be very huge for the browser (like, 234 946 559 indexes).
      <br>
      So I decided to identify each useful sub-memory of the GBA with its prefix:
      <br>
      <br>
      - EWRAM addresses start with "2"
      <br>
      - IWRAM with "3", I/O with "4"
      <br>
      - Palette RAM with "5"
      <br>
      - VRAM with "6"
      <br>
      - OAM with "7"
      <br>
      - Game Pak ROM with "8" and "9"
      <br>
      - Game Pak RAM with "E"
      <br>
      <br>
      Also, each sub-memory is relatively small, and some of them have <a href="http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Memory%20Map">mirrored data</a>:
      <br>
      <br>
      - EWRAM mirrors: every 0x40000 bytes from 0x02000000 to 0x02FFFFFF.
      <br>
      - IWRAM mirrors: every 0x8000 bytes from 0x03000000 to 0x03FFFFFF.
      <br>
      - I/O mirrors: The word 0x4000800 is mirrored every 0x10000 bytes from 0x04000000 to 0x04FFFFFF
      <br>
      - Palette RAM mirrors: every 0x400 bytes from 0x05000000 to 0x5FFFFFF.
      <br>
      - VRAM mirrors:
      <br>
      &nbsp; &nbsp; The region 0x06010000 - 0x06017FFF is mirrored at 0x06018000 - 0x0601FFFF.
      <br>
      &nbsp; &nbsp; The region 0x06000000 - 0x06020000 is mirrored every 0x20000 bytes from 0x06000000 to 0x06FFFFFF.
      <br>
      - OAM mirrors: every 0x400 bytes from 0x07000000 to 0x07FFFFFF.
      <br>
      - Game Pak ROM mirrors: at 0x0A000000 and 0x0C000000.
      <br>
      - Game Pak RAM mirror: at 0x0F000000.
      <br>
      <br>
      These mirrors can be handled virtually, so we only have to store the "real" data:
      <br>
      <br>
      - 256kb for EWRAM
      <br>
      - 32kb for IWRAM
      <br>
      - 1kb for I/O
      <br>
      - 1kb for palette RAM
      <br>
      - 96kb for VRAM
      <br>
      - 1kb for OAM
      <br>
      - 32mb max for Game Pak ROM
      <br>
      - 64kb max for Game Pak RAM
      <br>
      <br>
      The memory array, in consequence, will only contain 33 554 431 bytes maximum. (14% of the full address range)
      <br>
      Most GBA games fit into 4Mb ROMs, so playing them will only use 4 194 303 bytes. (1,7% of the full range)
      <br>
      <br>
      Here's the JS function I made to read or write data in the memory.
      <br>
      It's a big function, but it covers everything that can be done with the memory:
      <br>
      <br>
      - Accessing the sub-memories transparently
      <br>
      - Handling the memories mirrored data virtually
      <br>
      - Reading a value from memory
      <br>
      - Writing a value in memory
      <br>
      - Handling 8, 16 and 32-bit values
      <br>
      - Respecting the Little-Endianness of the GBA (more info <a href="http://nocash.emubase.de/gbatek.htm#gbamemorymap">here</a>, <a href="http://www.coranac.com/tonc/text/bitmaps.htm#ssec-data-format">here</a> or <a href="http://en.wikipedia.org/wiki/Endianness">here</a>)
      <br>
      - Allowing to write only on <a href="http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Memory-Mapped%20Hardware%20Registers">specific bits of I/O registers</a>
      <br>
      - Preventing a game to write on read-only I/O registers bits, but allowing the "internal" code to do so
      <br>
      - Handling illegal 8-bit writes in VRAM, Palette RAM and OAM (more info <a href="http://nocash.emubase.de/gbatek.htm#unpredictablethings">here</a>)
      <br>
      <br>
      <pre><code class="language-javascript">
/**
* This function allows to read and write in the console memory, and handles the mirrored data.
* Note that the GBA uses Little-Endianness (the 32-bit value 0x12345678 is stored as 0x78, 0x56, 0x34, 0x12).
* This function's parameters and return value, however, are in human-readable form (Big-Endian).
* @param address: the address to read from / write to.
* @param bytes: the number of bytes to read / write (1, 2 or 4, respectively for 8, 16 or 32-bit values).
* @param value (optional): 8/16/32bit value to write in memory, byte per byte, starting at the specified address.
* @param mask (optional): a 8/16/32bit mask defining on which bits the function has to write.
* @param force_write (for internal use only), allows the function to write on read-only addresses. 
* @return a 8/16/32-bit value read in memory at the specified address (if only 2 parameters are provided).
**/
function mem(address, bytes, value, mask, force_write){
  var prefix = address >> 24,                         // Address prefix (subarray index)
  subaddress;                                         // Address equivalent in the sub-array

  switch(prefix){
    case 0x2:                                         // EWRAM
      subaddress = ((address - 0x2000000) % 0x40000); // Handle sub-address and mirrors
      break;

    case 0x3:                                         // IWRAM
      subaddress = ((address - 0x3000000) % 0x8000);  // Handle sub-address and mirrors
      break;

    case 0x4:                                         // I/0
      subaddress = address - 0x4000000;               // Handle sub-address
      if(subaddress % 0x10000 == 0x800){
        subaddress = 0x800;                           // Handle mirrors
      }
      else if(subaddress % 0x10000 == 0x801){
        subaddress = 0x801;
      }
      break;

    case 0x5:                                         // Palette RAM
      subaddress = ((address - 0x5000000) % 0x400);
      break;

    case 0x6:                                         // VRAM
      subaddress = ((address - 0x6000000) % 0x20000); // Handle sub-address
      if(subaddress > 0x17FFF && subaddress < 0x20000){
        subaddress -= 8000;                           // Handle mirrors
      }
      break;

    case 0x7:                                         // OAM
      subaddress = ((address - 0x7000000) % 0x400);   // Handle sub-address and mirrors
      break;

    case 0x8:                                         // Game Pak ROM
    case 0x9:
      prefix = 8;
      subaddress = address - 0x8000000;               // Handle sub-address
      break;

    case 0xA:                                         // Game Pak ROM mirror 1
    case 0xB:
      prefix = 8;
      subaddress = address - 0xA000000;               // Handle sub-address
      break;

    case 0xC:                                         // Game Pak ROM mirror 2
    case 0xD:
      prefix = 8;
      subaddress = address - 0xC000000;               // Handle sub-address and mirrors
      break;

    case 0xE:                                         // Game Pak RAM
    case 0xF:
      prefix = 0xE;
      subaddress = ((address - 0xE000000) % 0x1000000);
      break;
  }

  // Handle read-only I/O registers
  z = 0xFFFFFFFF;                                     // No mask (default)
  if(!force_write && prefix == 0x4){
    if(subaddress == 0x0){
      z = 0xFFF7;                                     // Bit 3 of REG_DISPCNT
    }
    if(subaddress == 0x4){
      z = 0xFFF8;                                     // Bits 0-2 of REG_DISPSTAT
    }
    if(subaddress == 0x84){
      z = 0xFFF0;                                     // Bits 0-4 of REG_SOUNDCNT_X
    }
    if(subaddress == 0x120
    || subaddress == 0x122
    || subaddress == 0x124
    || subaddress == 0x126){
      if(mem(0x4000128, 2) & bitsC_D == 0x2000){      // In multi-player mode (bits C-D of REG_SCCNT_L == 10)
        z = 0x0000;                                   // Bits 0-16 of REG_SCD0/1/2/3
      }
    }
    if(subaddress == 0x128){
      if(mem(0x4000128, 2) & bitsC_D == 0x1000){      // In 32-bit normal mode (bits C-D of REG_SCCNT_L == 01)
        z = 0xFFFB;                                   // Bit 2 of REG_SCCNT_L
      }
      else if(mem(0x4000128, 2) & bitsC_D == 0x2000){ // In multi-player mode (bits C-D of REG_SCCNT_L == 10)
        z = 0xFF83;                                   // Bits 2-6 of REG_SCCNT_L
      }
      else if(mem(0x4000128, 2) & bitsC_D == 0x3000){ // In UART mode (bits C-D of REG_SCCNT_L == 11)
        z = 0xFF8F;                                   // Bits 4-6 of REG_SCCNT_L
      }
    }
    if(subaddress == 0x130){
      z = 0xF300;                                     // Bits 0-9 of REG_KEY
    }
    if(subaddress == 0x130){
      z = 0x7FFF;                                     // Bit 16 of REG_WSCNT
    }
  }

  // Handle forbidden 1-byte writes
  if(value && bytes == 1){                            // If we try to write 1 byte...
    if(
      prefix == 7                                     // On OAM
      ||                                              // Or OBJ region of VRAM in tiled mode
      (
        prefix == 6
        && (mem(0x4000000, 2) & bits0_2 >= 0x0)
        && (mem(0x4000000, 2) & bits0_2 <= 0x2)
        && subaddress >= 0x10000
        && subaddress <= 0x17FFF
      )
      ||                                              // Or OBJ region of VRAM in bitmap mode
      (
        prefix == 6
        && (mem(0x4000000, 2) & bits0_2 >= 0x3)
        && (mem(0x4000000, 2) & bits0_2 <= 0x5)
        && subaddress >= 0x14000
        && subaddress <= 0x17FFF
      )
    ){
      return;                                         // Nothing is written
    }
    if(
      prefix == 5                                     // If we try to write 1 byte on Palette RAM
      ||                                              // Or BG region of VRAM in tiled mode
      (
        prefix == 6
        && (mem(0x4000000, 2) & bits0_2 >= 0x0)
        && (mem(0x4000000, 2) & bits0_2 <= 0x2)
        && subaddress >= 0x0
        && subaddress <= 0xFFFF
      )
      ||                                              // Or BG region of VRAM in bitmap mode
      (
        prefix == 6
        && (mem(0x4000000, 2) & bits0_2 >= 0x3)
        && (mem(0x4000000, 2) & bits0_2 <= 0x5)
        && subaddress >= 0x0
        && subaddress <= 0x13FFF
      )
    ){
      bytes = 2;                                      // It's written twice (16 bits)
      value = value * 0x100 + value;
    }
  }

  // Write a value
  if(value){
    mask = mask || 0xFFFFFFFF;                        // Set default mask (all the bits are writable)
    mask = mask & z;                                  // Apply a read-only mask defined above
    for(i = 0; i < bytes; i++){                       // For each byte of the source value
      t = m[prefix][subaddress + i] || 0;             // Get the target value in memory (or 0 by default)
      u = mask & 0xFF;                                // Get the last byte of the mask
      v = 0xFF - u;                                   // And its opposite
      w = value & u;                                  // Apply the mini-mask to the source value
      t = t & v;                                      // Set the target bits to 0 ("actual value" AND "opposite of mask")
      t = t + w;                                      // Set the target bits to their real value ("actual value zeroed" + "source value masked")
      m[prefix][subaddress + i] = t;                  // Write that byte in memory
      value = value >> 8;                             // Offset the value (to access the next byte)
      mask = mask >> 8;                               // Offset the mask
    }
  }

  // Read a value
  else {
    for(t = 0, i = bytes; i; i--){                    // For each byte of the value in memory
      u = m[prefix][subaddress + i - 1] || 0;         // Read the byte (or 0 if undefined)
      t = t * 0x100 + u;                              // Add it at the end of the final result                         // Add it at the end of the final result
    }
    return t;                                         // And return it
  }
}
      </code></pre>
      
      <br>
      With this function, we can set a default value to some I/O registers
      <br>
      
      <pre><code class="language-javascript">
// I/O registers default values */
mem(0x4000088, 2, 0x0200);           // SOUNDBIAS
mem(0x4000802, 2, 0x0D00);           // REG_IMC_H
      </code></pre>

    </article>

    <br>
    <br>

    <nav>
      <a href="3.html" class=left>Previous page</a>
      <a href="5.html" class=right>Next page</a>
    </nav>

  </div>

  <!-- links -->
  <a href="http://twitter.com/MaximeEuziere">@MaximeEuziere</a>
  -
  <a href="..">Online version</a>
  -
  <a href="http://github.com/xem/gba.js">GitHub</a>

  <script>
    /**
    * Prism: Lightweight, robust, elegant syntax highlighting
    * MIT license http://www.opensource.org/licenses/mit-license.php/
    * @author Lea Verou http://lea.verou.me
    */(function(){var e=/\blang(?:uage)?-(?!\*)(\w+)\b/i,t=self.Prism={languages:{insertBefore:function(e,n,r,i){i=i||t.languages;var s=i[e],o={};for(var u in s)if(s.hasOwnProperty(u)){if(u==n)for(var a in r)r.hasOwnProperty(a)&&(o[a]=r[a]);o[u]=s[u]}return i[e]=o},DFS:function(e,n){for(var r in e){n.call(e,r,e[r]);Object.prototype.toString.call(e)==="[object Object]"&&t.languages.DFS(e[r],n)}}},highlightAll:function(e,n){var r=document.querySelectorAll('code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code');for(var i=0,s;s=r[i++];)t.highlightElement(s,e===!0,n)},highlightElement:function(r,i,s){var o,u,a=r;while(a&&!e.test(a.className))a=a.parentNode;if(a){o=(a.className.match(e)||[,""])[1];u=t.languages[o]}if(!u)return;r.className=r.className.replace(e,"").replace(/\s+/g," ")+" language-"+o;a=r.parentNode;/pre/i.test(a.nodeName)&&(a.className=a.className.replace(e,"").replace(/\s+/g," ")+" language-"+o);var f=r.textContent.trim();if(!f)return;f=f.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/\u00a0/g," ");var l={element:r,language:o,grammar:u,code:f};t.hooks.run("before-highlight",l);if(i&&self.Worker){var c=new Worker(t.filename);c.onmessage=function(e){l.highlightedCode=n.stringify(JSON.parse(e.data));l.element.innerHTML=l.highlightedCode;s&&s.call(l.element);t.hooks.run("after-highlight",l)};c.postMessage(JSON.stringify({language:l.language,code:l.code}))}else{l.highlightedCode=t.highlight(l.code,l.grammar);l.element.innerHTML=l.highlightedCode;s&&s.call(r);t.hooks.run("after-highlight",l)}},highlight:function(e,r){return n.stringify(t.tokenize(e,r))},tokenize:function(e,n){var r=t.Token,i=[e],s=n.rest;if(s){for(var o in s)n[o]=s[o];delete n.rest}e:for(var o in n){if(!n.hasOwnProperty(o)||!n[o])continue;var u=n[o],a=u.inside,f=!!u.lookbehind||0;u=u.pattern||u;for(var l=0;l<i.length;l++){var c=i[l];if(i.length>e.length)break e;if(c instanceof r)continue;u.lastIndex=0;var h=u.exec(c);if(h){f&&(f=h[1].length);var p=h.index-1+f,h=h[0].slice(f),d=h.length,v=p+d,m=c.slice(0,p+1),g=c.slice(v+1),y=[l,1];m&&y.push(m);var b=new r(o,a?t.tokenize(h,a):h);y.push(b);g&&y.push(g);Array.prototype.splice.apply(i,y)}}}return i},hooks:{all:{},add:function(e,n){var r=t.hooks.all;r[e]=r[e]||[];r[e].push(n)},run:function(e,n){var r=t.hooks.all[e];if(!r||!r.length)return;for(var i=0,s;s=r[i++];)s(n)}}},n=t.Token=function(e,t){this.type=e;this.content=t};n.stringify=function(e){if(typeof e=="string")return e;if(Object.prototype.toString.call(e)=="[object Array]"){for(var r=0;r<e.length;r++)e[r]=n.stringify(e[r]);return e.join("")}var i={type:e.type,content:n.stringify(e.content),tag:"span",classes:["token",e.type],attributes:{}};i.type=="comment"&&(i.attributes.spellcheck="true");t.hooks.run("wrap",i);var s="";for(var o in i.attributes)s+=o+'="'+(i.attributes[o]||"")+'"';return"<"+i.tag+' class="'+i.classes.join(" ")+'" '+s+">"+i.content+"</"+i.tag+">"};if(!self.document){self.addEventListener("message",function(e){var n=JSON.parse(e.data),r=n.language,i=n.code;self.postMessage(JSON.stringify(t.tokenize(i,t.languages[r])));self.close()},!1);return}var r=document.getElementsByTagName("script");r=r[r.length-1];if(r){t.filename=r.src;document.addEventListener&&!r.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",t.highlightAll)}})();
    Prism.languages.markup={comment:/&lt;!--[\w\W]*?--(&gt;|&gt;)/g,prolog:/&lt;\?.+?\?&gt;/,doctype:/&lt;!DOCTYPE.+?&gt;/,cdata:/&lt;!\[CDATA\[[\w\W]+?]]&gt;/i,tag:{pattern:/&lt;\/?[\w:-]+\s*[\w\W]*?&gt;/gi,inside:{tag:{pattern:/^&lt;\/?[\w:-]+/i,inside:{punctuation:/^&lt;\/?/,namespace:/^[\w-]+?:/}},"attr-value":{pattern:/=(('|")[\w\W]*?(\2)|[^\s>]+)/gi,inside:{punctuation:/=/g}},punctuation:/\/?&gt;/g,"attr-name":{pattern:/[\w:-]+/g,inside:{namespace:/^[\w-]+?:/}}}},entity:/&amp;#?[\da-z]{1,8};/gi};Prism.hooks.add("wrap",function(e){e.type==="entity"&&(e.attributes.title=e.content.replace(/&amp;/,"&"))});
    Prism.languages.css={comment:/\/\*[\w\W]*?\*\//g,atrule:/@[\w-]+?(\s+.+)?(?=\s*{|\s*;)/gi,url:/url\((["']?).*?\1\)/gi,selector:/[^\{\}\s][^\{\}]*(?=\s*\{)/g,property:/(\b|\B)[a-z-]+(?=\s*:)/ig,string:/("|')(\\?.)*?\1/g,important:/\B!important\b/gi,ignore:/&(lt|gt|amp);/gi,punctuation:/[\{\};:]/g};Prism.languages.markup&&Prism.languages.insertBefore("markup","tag",{style:{pattern:/(&lt;|<)style[\w\W]*?(>|&gt;)[\w\W]*?(&lt;|<)\/style(>|&gt;)/ig,inside:{tag:{pattern:/(&lt;|<)style[\w\W]*?(>|&gt;)|(&lt;|<)\/style(>|&gt;)/ig,inside:Prism.languages.markup.tag.inside},rest:Prism.languages.css}}});
    Prism.languages.javascript={comment:{pattern:/(^|[^\\])(\/\*[\w\W]*?\*\/|\/\/.*?(\r?\n|$))/g,lookbehind:!0},string:/("|')(\\?.)*?\1/g,regex:{pattern:/(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/g,lookbehind:!0},keyword:/\b(var|let|if|else|while|do|for|return|in|instanceof|function|new|with|typeof|try|catch|finally|null|break|continue)\b/g,"boolean":/\b(true|false)\b/g,number:/\b-?(0x)?\d*\.?\d+\b/g,operator:/[-+]{1,2}|!|=?&lt;|=?&gt;|={1,2}|(&amp;){1,2}|\|?\||\?|\*|\//g,ignore:/&(lt|gt|amp);/gi,punctuation:/[{}[\];(),.:]/g};Prism.languages.markup&&Prism.languages.insertBefore("markup","tag",{script:{pattern:/(&lt;|<)script[\w\W]*?(>|&gt;)[\w\W]*?(&lt;|<)\/script(>|&gt;)/ig,inside:{tag:{pattern:/(&lt;|<)script[\w\W]*?(>|&gt;)|(&lt;|<)\/script(>|&gt;)/ig,inside:Prism.languages.markup.tag.inside},rest:Prism.languages.javascript}}});
    Prism.languages.java={comment:{pattern:/(^|[^\\])(\/\*[\w\W]*?\*\/|\/\/.*?(\r?\n|$))/g,lookbehind:true},string:/("|')(\\?.)*?\1/g,keyword:/\b(abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\b/g,"boolean":/\b(true|false)\b/g,number:/\b-?(0x)?\d*\.?\d+\b/g,operator:/[-+]{1,2}|!|=?<|=?>|={1,2}|(&){1,2}|\|?\||\?|\*|\/|%|\^|(<){2}|($gt;){2,3}|:|~/g,ignore:/&(lt|gt|amp);/gi,punctuation:/[{}[\];(),.:]/g}
</script>

</body>
</html>